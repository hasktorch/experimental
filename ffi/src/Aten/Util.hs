
-- generated by using spec/Declarations.yaml

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.Util where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.Type
import FFICXX.Runtime.Cast
import Aten.Type.IntArrayRef.RawType

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"

newIntArrayRef1 :: Int64 -> IO IntArrayRef
newIntArrayRef1 dim0 = cast_fptr_to_obj <$> [C.block| at::IntArrayRef* { return new at::IntArrayRef({$(int64_t dim0)});}|]

newIntArrayRef2 :: Int64 -> Int64 -> IO IntArrayRef
newIntArrayRef2 dim0 dim1 = cast_fptr_to_obj <$> [C.block| at::IntArrayRef* { return new at::IntArrayRef({$(int64_t dim0), $(int64_t dim1)});}|]

newIntArrayRef3 :: Int64 -> Int64 -> Int64 -> IO IntArrayRef
newIntArrayRef3 dim0 dim1 dim2 = cast_fptr_to_obj <$> [C.block| at::IntArrayRef* { return new at::IntArrayRef({$(int64_t dim0), $(int64_t dim1), $(int64_t dim2)});}|]

newIntArrayRef4 :: Int64 -> Int64 -> Int64 -> Int64 -> IO IntArrayRef
newIntArrayRef4 dim0 dim1 dim2 dim3 = cast_fptr_to_obj <$> [C.block| at::IntArrayRef* { return new at::IntArrayRef({$(int64_t dim0), $(int64_t dim1), $(int64_t dim2), $(int64_t dim3)});}|]

