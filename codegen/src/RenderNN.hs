{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE QuasiQuotes #-}
module RenderNN where

import Data.Yaml (ParseException)
import qualified Data.Yaml as Y
import Text.Shakespeare.Text (st)
import Data.Text (Text)
import qualified Data.Text.IO as T

import qualified ParseNN as NN
import qualified ParseHeadersForNN as HNN
import ParseFunctionSig as P
import RenderCommon
import qualified Data.Map as M
import Text.Megaparsec (parse)
import Control.Exception.Safe (throw)


dropGenerator :: [Parameter] -> [Parameter]
dropGenerator params = filter (\v' -> ptype v' /= Ptr GeneratorType) params

mkBackwardAndForward :: (NN.NN', (HNN.Function, HNN.Function)) -> [P.Function]
mkBackwardAndForward (nn, (thnn_fwd,thnn_bwd)) = [nn_forward, nn_forward_out, nn_backward, nn_backward_out]
  where
    fn = NN.func' nn
    params = parameters fn
--    has_target = or $ map (\v -> pname v == "target") params
    nn_forward = fn {
      name = (name fn) ++ "_forward"
      , parameters =
          params
          `HNN.removeUnusedArgs` HNN.thnnArgs thnn_fwd
      }
    nn_forward_out = fn {
      name = (name fn) ++ "_forward_out"
      , parameters =
          [tensor_param] ++ buffer_param ++ params
          `HNN.removeUnusedArgs` HNN.thnnArgs thnn_fwd
      }
    nn_backward = fn {
      name = (name fn) ++ "_backward"
      , parameters =
          (dropGenerator $ [grad_output] ++ params ++ buffer_param ++ output_arguments)
            `HNN.removeUnusedArgs` HNN.thnnArgs thnn_bwd
      , retType = TenType Tensor
      }
    nn_backward_out = fn {
      name = (name fn) ++ "_backward_out"
      , parameters =
          (dropGenerator $ [grad_input, grad_output] ++ params ++ buffer_param ++ output_arguments)
            `HNN.removeUnusedArgs` HNN.thnnArgs thnn_bwd
      , retType = TenType Tensor
      }
    tensor_param = Parameter
      (TenType Tensor)
      "output"
      Nothing
    grad_input = Parameter
      (TenType Tensor)
      "grad_input"
      Nothing
    grad_output = Parameter
      (TenType Tensor)
      "grad_output"
      Nothing
    buffer_param =
      case (NN.buffers' nn) of
        Nothing -> []
        Just b -> map (\n -> Parameter (TenType Tensor) n Nothing) b
    output_arguments = HNN.outputArgs (HNN.cname thnn_fwd) $ HNN.thnnArgs thnn_fwd


renderFunctions :: [(NN.NN',(HNN.Function,HNN.Function))] -> Text
renderFunctions nfs = mconcat $ concat $ flip map nfs $ \(nf,(fwd,bwd)) -> map (functionToCpp False "at::") (mkBackwardAndForward (nf,(fwd,bwd)))

decodeThnn :: FilePath -> IO (M.Map String HNN.Function)
decodeThnn thnnFileName =
  readFile thnnFileName >>= \f -> do
    case parse HNN.functions "" f of
      Left exception -> throw exception
      Right fs -> pure $ M.fromList $ map (\f' -> ((HNN.fname f') <> "_" <> (HNN.cname f'),f')) fs

mergeNNAndThnn :: M.Map String HNN.Function -> [NN.NN'] -> Either String [(NN.NN', (HNN.Function, HNN.Function))]
mergeNNAndThnn thnn_funcs nn_funcs =
  sequence $ flip map nn_funcs $ \f ->
    case (M.lookup ((NN.cname' f)<>"_updateOutput") thnn_funcs, M.lookup ((NN.cname' f)<>"_updateGradInput") thnn_funcs) of
      (Just fwd, Just bwd) -> Right (f,(fwd,bwd))
      (Just _, Nothing) -> Left $ "Can not find " <> (NN.cname' f) <> "_updateGradInput"
      (Nothing, _) -> Left $ "Can not find " <> (NN.cname' f) <> "_updateOutput"

decodeAndCodeGen :: String -> String -> String -> IO ()
decodeAndCodeGen basedir fileName thnnFileName = do
  funcs <- Y.decodeFileEither fileName :: IO (Either ParseException [NN.NN'])

  thnn_funcs <- decodeThnn thnnFileName

  case funcs of
    Left err' -> throw err'
    Right fns -> do
      fnsWithThnn <- do
        case (mergeNNAndThnn thnn_funcs fns) of
          Right v' -> pure v'
          Left e -> fail e
      T.writeFile (basedir <> "/Aten/NN.hs") [st|
-- generated by using spec/nn.yaml and deps/libtorch/include/ATen/Functions.h

{-# LANGUAGE DataKinds #-}
{-# LANGUAGE PolyKinds #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE OverloadedStrings #-}

module Aten.NN where

import qualified Language.C.Inline.Cpp as C
import qualified Language.C.Inline.Cpp.Exceptions as C
import qualified Language.C.Inline.Context as C
import qualified Language.C.Types as C
import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign

import qualified Data.Map as Map

import Foreign.C.String
import Foreign.C.Types
import Foreign
import Aten.NativeFunctions.Type

C.context $ C.cppCtx <> mempty { C.ctxTypesTable = typeTable }

C.include "<ATen/ATen.h>"

#{renderFunctions fnsWithThnn}
|]
